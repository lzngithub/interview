# 前端安全

## 简单了解 web 的攻击方式有哪些

1. xss：跨站脚本攻击（cross site sripting）
2. csrf：跨站请求伪造（cross site request forgery）

## xss

攻击者在网站中嵌入恶意代码，当用户打开网站的时候，恶意代码被运行，可以用于盗取用户的 cookie，权限，账号密码或者下载病毒等。

### 嵌入代码的实现方式

1. 一般在用户界面可以输入的地方，比如：登陆，信息采集，评论区等，在这些地方去输入恶意代码;
2. 通过恶意链接，用户点击则会打开目标网站，执行恶意链接中的代码，比如一些搜索网站通过 url 去携带查询搜索参数。

### xss 分类

#### 1.反射型 xss

也叫非持久型 xss，顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。

反射型 XSS 的攻击步骤

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，浏览器打开被攻击网站，向服务器发起请求，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 2.基于 dom 的 xss 攻击

目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。

基于 DOM 的 XSS 攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 3.存储型 xss 攻击

又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### 解决办法

解决办法：

- 尽量不要使用 eval 、innerHTML、setInterval 等可执行字符串的方法；
- 使用 Vue/React 技术栈，尽量不要使用 v-html/dangerouslySetInnerHTML 功能
- 对动态渲染的 html 标签做转义
- 渲染的数据都必须来自于服务端；尽量不要从 URL 等这种 DOM API
- 设置严格的 CSP，严格的 CSP 在 XSS 的防范中可以起到以下的作用：

#### Content Security Policy

使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单，有以下作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
- 合理使用上报可以及时发现 XSS，利于尽快修复问题。

## csrf

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### 攻击步骤

- 受害者登录 A 网站，并且保留了登录凭证（Cookie）
- 攻击者引诱受害者访问 B 网站
- B 网站向 A 网站发送了一个请求（这个就是下面将介绍的几种伪造请求的方式），浏览器请求头中会默认携带 A 网站的 Cookie
- A 网站服务器收到请求后，经过验证发现用户是登录了的，所以会处理请求

### csrf 攻击可以实现的原因

为什么在网站 B 向 A 网站发送了一个请求会默认携带 A 网站的 Cookie，这跟 cookie 的特点有关。

1. 读写 Cookie 有跨域限制，通常只能读取当前请求域名下的 cookie，也可以设置 Path 限制；
2. 浏览器在发起请求时，默认自动携带当前请求域名下的 Cookie，无论何种方式，如何发起的请求；
3. Cookie 有生命周期，只在会话期有效或者持久有效。

重点跟第二点有关，无论何种方式发起的请求，无论是不是在当前网站下发起的请求，默认自动携带请求域名下的 Cookie。

引言：其实 Google 浏览器版本更新至今，已经完全禁止当前域名下的跨域请求携带第三方 cookie 了，所以很大程度上，在客户端底座都预防了 CSRF 攻击，但是其他的浏览器，有没有做这一项限制不晓得，而一些安全测评机构肯定也不会做这方面的安全限制。

### 攻击实现方式

因为 csrf 是在第三方发起的请求，因此会受到浏览器同源策略的影响，因此一般是通过 html 标签的方式去发起请求，不会受到同源策略的影响。有 img form 等。

```html
<img src="http://bank.example/withdraw?amount=10000&for=hacker" />

<form action="http://bank.example/withdraw" method="POST">
  <input type="hidden" name="account" value="xiaoming" />
  <input type="hidden" name="amount" value="10000" />
  <input type="hidden" name="for" value="hacker" />
</form>
<script>
  document.forms[0].submit();
</script>

<a
  href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker"
  taget="_blank"
>
  重磅消息！！
  <a
/></a>
```

以上链接都可以发起请求。

### 防御方式

CSRF 通常发生在第三方域名，并且 CSRF 攻击者不能获取到受害者的 cookie 等信息，只是借用他们的登录状态来伪造请求。所以我们可以针对这两点来制定防范措施：

#### 同源检测

既然 CSRF 大多来自第三方网站，那么我们就直接禁止第三方域名（或者不受信任的域名）对我们发起请求。

在 HTTP 协议中，每一个异步请求都会携带两个 Header，用于标记来源域名：

- Origin Header
- Referer Header

这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。同时服务器应该优先检测 Origin。为了安全考虑，相比于 Referer，Origin 只包含了域名而不带路径。

#### CSRF Token

服务端可以通过响应头的 set-cookie 给浏览器下发一个随机值 token，让后续每次发起的请求 在 header 或者 body 或者 queryString 中植入它。

上文讲述，页面的 JS 脚本读写 cookie 有跨域限制，即只能读取同源 cookie，所以服务端接口就可以通过请求报文中是否含有 token，以及含有的 token 是否是自己下发的 来判断该请求是否来自可信任的页面。

#### 给 Cookie 设置合适的 SameSite

> 该属性需要浏览器支持

当从 A 网站登录后，会从响应头中返回服务器设置的 Cookie 信息，而如果 Cookie 携带了 SameSite=strict 则表示完全禁用第三方站点请求头携带 Cookie，比如当从 B 网站请求 A 网站接口的时候，浏览器的请求头将不会携带该 Cookie。

- Samesite=Strict，这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
- Samesite=Lax，这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。（默认）
- None 任何情况下都会携带；

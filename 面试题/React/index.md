# React 面试题

## 题目

1. React 是什么？
2. 你能解释一下 React 的虚拟 DOM(Virtual DOM)是什么，以及它如何工作吗？
3. 什么是 jsx？
4. React 中 jsx 与虚拟 DOM 的关系?
5. 怎么理解 Fiber 架构？
6. Fiber 的性能优化是怎么理解的？
7. React 中 diff 算法是什么？
8. 在 React 组件中，何时应该使用状态(state)和何时应该使用属性(props)？
9. 什么是 React 的组件生命周期，生命周期方法常用的有哪些，以及它如何被使用？
10. 触发状态更新得方法有哪些，这个状态更新的方法是同步的还是异步的？
11. 使用 React Hooks 有哪些要注意的地方？
12. 什么是 React 的 Context API，它用于什么场景？
13. 如何实现一个简单的 React Redux 应用？
14. Redux 在 React 中如何使用？
15. 你能解释一下 React 的不可变性原则吗？
16. 如何在 React 应用中实现数据流（数据流图）？
17. React 路由是什么？如何在 React 应用中使用它？
18. 如何处理在 React 中的异步操作？
19. 在 React 中如何实现延迟加载（懒加载）和代码拆分？
20. 在 React 应用中如何实现全局状态管理？
21. Redux 与 MobX 的主要区别是什么？你更倾向于使用哪种？为什么？
22. 在 React 中如何使用并比较不同的状态管理库（如 Redux，MobX 等）？
23. 如何创建可重用的 React 组件？
24. 在大型 React 应用中，如何进行组件的测试和调试？
25. 在 React 中如何使用和比较不同的路由库（如 react-router，react-router-dom 等）?
26. 你如何理解 React 的函数组件和类组件的区别，你更倾向于使用哪一种，为什么？
27. 在 React Hooks 中，useState 和 useEffect 的主要区别是什么？
28. 在 React 中，如何处理多线程和并发问题？
29. React Concurrent 模式是什么？它有哪些特点？
30. 在 React 中，如何使用和比较不同的状态管理库（如 Redux，MobX 等）？
31. 你能解释一下 React 的错误边界（Error Boundaries）吗？
32. Error Boundaries 在 React 中如何使用？
33. 在 React 中如何使用事件处理函数(Event Handling Functions)?
34. 什么是事件代理(Event Delegation)?
35. 在 React 中如何使用和比较不同的状态管理库（如 Redux、MobX、Zustand 等）?
36. 你能解释一下 React 的“props in, props out”原则吗？
37. React Hooks 和类组件相比有什么优点和缺点？
38. 如何优化 React 应用的性能？
39. React 与 Vue 的主要区别是什么？
40. 如何在 React 应用中实现国际化(i18n)和本地化(l10n)？
41. React Testing Library 是什么，以及如何使用它进行单元测试和集成测试？
42. React Hooks 和 React Classes 的主要区别是什么？
43. 什么是 React 的“Context API”，如何使用它？
44. 在大型 React 应用中，如何管理和组织组件代码？
45. 如何使用 React Router 进行路由管理？
46. React 和 Flux, Redux 的关系是什么？
47. 什么是 React 的“Props 查漏补缺”？
48. 在 React 中如何处理大量数据，以及优化渲染性能？
49. 你能解释一下 React 的“纯组件(Pure Components)”是什么，以及它们如何工作吗？
50. 如何使用 React Hooks 实现“useState”的初始值设定？
51. React Concurrent Mode 是什么，它与传统的 React 应用有何不同？
52. 你能解释一下 React 的“Hook Composition”吗？
53. 如何使用 React Router v5 实现程序化导航(Programmatic Navigation)？
54. 在 React 中如何处理文件上传和下载？
55. 你能解释一下 React 的“副作用(Side Effects)”以及如何使用 useEffect 来处理它们吗？
56. 如何使用 React 中的 useReducer Hook 来实现应用状态管理？
57. 你能解释一下 React 的 useCallback Hook 和 useMemo Hook 吗？它们在什么情况下使用？
58. 在大型 React 项目中，如何管理和优化组件的性能？
59. 你能解释一下 React 的 useRef Hook 吗？它在什么情况下使用？
60. 在 React 中如何使用和比较不同的状态管理库（如 Redux、MobX、Zustand 等）?
61. 你能解释一下 React Hooks 的" Memoization "概念吗?
62. 如何在 React 中实现服务器端渲染(Server-Side Rendering, SSR)？
63. React Hooks 和函数组件与类组件相比有哪些优缺点？
64. 你能解释一下 React 的 useImperativeHandle Hook 吗？它有什么作用？
65. 在 React 应用中如何处理与应用逻辑相关的全局状态？
66. 如何使用 React Router v5 实现嵌套路由(Nested Routes)？
67. React Hooks 和 React Classes 相比有什么优点和缺点？
68. 什么是 React 的状态(State)，它有什么重要性？
69. 在 React 应用中如何正确地使用 props 和 state？
70. 什么是 React 的上下文(Context)，以及它如何被使用？
71. 在 React 应用中如何正确地使用和避免使用全局状态？
72. 在 React 应用中如何管理全局状态？
73. 如何在 React 中实现延迟加载(Lazy Loading)？
74. 什么是 React 的 useCallback，它有什么作用？
75. 如何在 React 中实现组件的封装和复用？
76. 如何在 React 应用中避免使用全局状态？
77. 如何在 React 中正确地使用事件处理函数(Event Handlers)？
78. 在 React 应用中如何管理组件之间的通信？
79. 如何优化 React 应用的性能？
80. 在 React 中如何正确地使用 useReducer 和 useContext？
81. 如何正确地在 React 组件中使用高阶组件(HOC)？
82. 在 React 应用中如何正确地使用和比较不同的状态管理库（如 Redux、MobX 等）？
83. 如何正确地在 React 中使用 props 和 state 来管理应用状态？
84. 如何在 React 应用中实现国际化(i18n)和本地化(l10n)？
85. 如何正确地在 React 中使用事件代理(Event Delegation)？
86. 在 React 应用中如何正确地使用和比较不同的路由库（如 react-router、react-router-dom 等）?
87. 如何正确地在 React 中使用 useMemo 和 useCallback 来优化性能？
88. 如何正确地在 React 中使用事件代理(Event Delegation)？
89. 你能解释一下 React 的 Hook 吗？它们是做什么用的？
90. 在 React 中，组件是什么？
91. 什么是状态(state)在 React 中的重要性？
92. 什么是 props，它们在 React 中如何使用？

## 答案

### 1. React 是什么？

思路：这种一般问是什么，就介绍某一样东西，比如电脑是什么，要让人有一个直观印象。回答要点：

1. 起源于 Facebook 的内部项目，于 2013 年开源，是一个用于构建界面的 javascript 库。（大概印象）
2. 声明式编程方式、组件化、轻量级和灵活。（特点）
3. 使用虚拟 DOM 来有效地操作 DOM。（设计模式）
4. 开发团队和社区资源丰富，api 简洁，但没有官方的的解决方案，选型成本高，同时因为过于灵活，对代码设计要求高（个人理解）。

补充（不用回答）：

- 组件化：React 采用组件设计模式，将界面拆分为一个个组件，每个组件负责自身的功能和数据，通过组合不同的组件可以构建出复杂的界面。
- 声明式编程范式：React 使用声明式编程范式，它关注的是要做什么，而不是如何做。开发者通过描述界面的状态和行为，而不是直接操作 DOM 来构建用户界面，这部分工作交给框架 React 来做。
- 虚拟 DOM：React 使用虚拟 DOM 来优化性能，它通过在内存中创建虚拟节点，并使用虚拟 DOM 来更新和渲染真实的 DOM，从而减少直接操作 DOM 的开销。
- 轻量级和灵活：React 是一个轻量级的库，它的核心 API 简洁明了，易于学习和使用。同时，React 具有很强的灵活性，可以根据项目的需求使用不同的插件和工具来扩展其功能。

### 2. 你能解释一下 React 的虚拟 DOM(Virtual DOM)是什么，以及它如何工作吗？

React 的虚拟 DOM（Virtual DOM）是一个模拟 DOM 树的 Javascript 对象，它是对真实 DOM 的一种描述,主要描述 DOM 结构及其属性信息。

虚拟 DOM 在 React 组件的挂载阶段和更新阶段都会作为关键角色出现，其参与的工作流程如下：

- 挂载阶段，React 将结合 JSX 的描述构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射（触发渲染流水线）。
- 更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM。

虚拟 DOM 的工作原理：

1. 当状态（state）发生改变时，React 会生成一个新的虚拟 DOM，而不是直接对真实的 DOM 进行操作。
2. React 会通过一种算法（Diffing 算法）比较新旧两个虚拟 DOM 的差异。
3. 根据这些差异，React 知道哪些部分的 DOM 需要被更新，然后会向真实的 DOM 发送改变指令（即 React.render 方法）。

### 3. 什么是 jsx？

React JSX 是一种 JavaScript 的语法扩展，是对 React.createElement()的抽象，是一套语法糖()，运用于 React 架构中，JSX 是用来声明 React 当中的元素，React 使用 JSX 来描述用户界面，在不使用 JSX 的情况下一样可以工作，然而使用 JSX 可以提高组件的可读性。

补充：

jsx 转化为真实 dom 的过程: JSX 结构 --（babel 转义）--(React.createElement 处理) --> React Element 对象（虚拟 dom） --> Fiber 节点 --> 真实 doom 节点

### 4. React 中 jsx 与虚拟 DOM 的关系?

JSX 和虚拟 DOM 在 React 中是密切相关的，JSX 负责在虚拟 DOM 上描述界面，而虚拟 DOM 则是 JSX 在内存中的表示，二者关系如下：

1. JSX 是 React 的编程语言，它使用类似 HTML 的语法描述界面，但实际上是通过 React.createElement 或函数组件的渲染函数将其转化为虚拟 DOM。
2. 虚拟 DOM 是 React 为了提高性能而采用的一种策略，它将 JSX 描述的界面转化为一个轻量级的 JavaScript 对象树，这个对象树又被称为虚拟 DOM 树。当 React 组件的状态发生变化时，React 会通过比较新旧虚拟 DOM 树的差异，然后更新在 DOM 中真实存在的部分，完成页面的更新渲染。

### 5. 怎么理解 Fiber 架构？

Fiber 架构是 React 16 新的架构。为了解决老结构不能满足 React 的设计理念。

老的结构：

1. react16 之前 stack 架构，递归遍历组件树成本很高，会造成主线程被持续占⽤，结果就是主线程上的布局、动画等周期性任务就⽆法⽴即得到处理，造成视觉上的卡顿，影响⽤户体验。

新的架构：

1. Fiber 架构 任务分解，避免主线程的持续占用造成卡顿问题
2. 增量渲染，把渲染任务拆分成多块。
3. 更新时候能够暂停，终止，复用渲染任务。
4. 给不同类型的更新赋予优先级。

### 6. Fiber 的性能优化是怎么理解的？

老的架构：会造成主线程被持续占⽤，结果就是主线程上的布局、动画等周期性任务就⽆法⽴即得到处理，造成视觉上的卡顿，影响⽤户体验

新的架构：

1. 主线程上布局，动画等周期任务在每帧都有运行的机会.
2. 防止 JS 堵塞线程而使得用户的交互没有反应。
3. 可中断的执行机制，提供了提前执行高优先级任务的可能性，这种做法其实是基于人机交互，优化用户的体感。

### 7. React 中 diff 算法是什么？

对于更新的组件，React 会将当前组件与该组件上次更新时对应的 Fiber 节点比较，将比较的结果生成新的 Fiber 节点，这个比较的算法就叫做 diff 算法。

传统 diff 算法通过循环递归对节点进行依次对比，算法复杂度达到 O(n^3) ，，规定了 react 中的 diff 算法的三个限制：

1. 只对同级元素 diff，跨层级的 dom 不会复用；
2. type 不同时，不会复用，会直接销毁该节点及子孙节点；
3. key 不同时，不会复用

通过优化算法，React diff 的算法复杂度降低到了 O(n)。

## 8. 在 React 组件中，state 和 props 是什么？何时应该使用状态(state)和何时应该使用属性(props)？

在 React 中，state 指的是组件内部维护的一个状态，它可以存储组件的数据，控制组件的行为和渲染。当 state 发生改变的时候，React 会自动重新渲染组件，以反映出最新的状态。

React 中的 props 是一个 JavaScript 对象，它是组件之间通信的一种方式，是调用方传递给组件的数据和配置信息的一种机制。props 是只读的，用于从外部传递数据给组件。

使用原则，对于组件的状态管理，应优先使用内部状态，是组件之间达到高内聚，低耦合，同时具体使用时机要根据业务，优化等因素综合考虑后再决定。

得分点：

- state：内部状态，改变 React 会自动重新渲染。
- props：从外部传递数据给组件，组件通信得一种机制。
- 使用原则：尽可以使用 state，低耦合，高内聚，同时灵活根据业务调整。

## 9. 什么是 React 的组件生命周期，生命周期方法常用的有哪些，以及它如何被使用？

React 的组件生命周期是指组件从被创建到被销毁的过程，包括组件的初始化、更新、卸载等阶段。在 React 中，组件的生命周期主要分为三个阶段：挂载阶段、更新阶段、卸载阶段。

组件的生命周期方法是指 React 为组件在不同的生命周期阶段提供的特殊方法，以便开发者可以在这些阶段更好地控制组件的行为。这些方法包括：

- 挂载阶段：组件被创建并执行初始化，然后被挂载到 DOM 中，完成第一次渲染。这个阶段可以调用的方法有 constructor 和 componentDidMount。constructor 用于在组件被创建时进行 state 的初始化和绑定事件处理方法等工作，而 componentDidMount 则用于在组件被挂载到 DOM 后执行一些操作，如网络请求等。
- 更新阶段：当组件的 props 或 state 发生变化，或者组件进行重渲染时。这个阶段可以调用的方法有 static getDerivedStateFromProps、render、getSnapshotBeforeUpdate 和 componentDidUpdate。getDerivedStateFromProps 用于在 props 变化时更新组件的 state，render 用于重新渲染组件，getSnapshotBeforeUpdate 用于在组件重新渲染前捕获一些快照，componentDidUpdate 则用于在组件更新后执行一些操作，如重新渲染等。
- 卸载阶段：当组件从 DOM 中被卸载时。这个阶段可以调用的方法有 componentWillUnmount，用于执行一些必要的清理工作，如网络请求的取消，dom 监听事件得取消等。

总之，React 的组件生命周期和生命周期方法为开发者提供了在组件不同阶段更好地控制组件行为的能力，可以在组件挂载、更新、卸载等阶段进行必要的操作，从而提升 React 应用的性能和体验。

得分点：

- 组件从被创建到被销毁的过程，分为：挂载阶段、更新阶段、卸载阶段。function 组件没有实例，也就没有对应的生命周期。
- 不同的生命周期阶段提供的特殊方法，以便开发者可以在这些阶段更好地控制组件的行为，从而提升 React 应用的性能和体验。
- 三个阶段常用得周期方法(按顺序展示)：
  - 挂载阶段（4 个）：constructor(props)、static getDerivedStateFromProps(nextProps, prevState)、render()、componentDidMount();
  - 更新阶段（5 个）：static getDerivedStateFromProps(nextProps, prevState)、shouldComponentUpdate(nextProps, nextState)、render()、getSnapshotBeforeUpdate(prevProps, prevState)、componentDidUpdate(prevProps, prevState, snapshot)
  - 销毁阶段（1 个）：componentWillUnmount()

## 10. 触发状态更新得方法有哪些，这个状态更新的方法是同步的还是异步的？

在 React 中触发状态更新的方法有下面五种：

- ReactDOM.render()
- this.setState()
- this.forceUpdate()
- useState()
- useReducer()

状态更新的方法本身执行不是异步的，是因为其批处理机制给人一种异步的假象。

生命周期函数和合成事件中：其批处理机制给人一种异步的假象。

原生事件和异步代码中：原生事件不会触发 react 的批处理机制,异步代码等待同步代码执行完毕再执行,因而直接更新。
